#!/usr/bin/env python3
"""
Filter to toggle Python dictionaries between literal and dict() constructor format.

Reads and evaluates stdin for a Python dictionary. If the dict is a literal
(e.g. `{'a':1}`) it is converted to a constructor call (eg `dict(a=1)`).
Otherwise it is converted into a literal.

The input dict may be multi-line, but must be the only value present, barring an
optional trailing comma, which will be replicated on the output. The output is
always multi-line, with one key-value pair per line, eg:

    {
        'a': 1,
    }

or

    dict(
        a=1,
    )

"""
import ast
import dataclasses
import sys

def error(*lines, exitval=1):
    print('\n'.join(lines), file=sys.stderr)
    sys.exit(exitval)

def get_indentation(string):
    indentation = []
    for char in string:
        assert char != '\t'
        if char != ' ':
            break
        indentation += ' '
    return ''.join(indentation)

def is_oneple(value):
    """Is given value a tuple of one value?"""
    return isinstance(value, tuple) and len(value) == 1

def get_dict_value(value):
    dict_value = value[0] if is_oneple(value) else value
    if not isinstance(dict_value, dict):
        error(f'Error: Input is a {type(value).__name__}, should be a dict.')
    return dict_value

@dataclasses.dataclass
class ParsedDict:
    indentation: str
    dict_value: dict
    is_literal: bool
    trailing_comma: bool

def parse_input(string):
    """Parse the given string for a single Python dictionary, using 'eval'"""
    try:
        value = eval(string)
    except SyntaxError as exc:
        error(
            f'Error: {exc.msg}, line {exc.lineno}:',
            f'{exc.text}',
            f'{" " * (exc.offset - 1)}^',
        )
    return ParsedDict(
        indentation=get_indentation(string),
        dict_value=get_dict_value(value),
        is_literal=string.strip().startswith('{'),
        trailing_comma=is_oneple(value),
    )

def format_literal(parsed):
    """Return list of str containing the given dict as a literal"""
    parts = ['{']
    for key, value in sorted(parsed.dict_value.items()):
        parts.append(f'    {key!r}: {value!r},')
    parts.append('},' if parsed.trailing_comma else '}')
    return parts

def format_constructor(parsed):
    """Return list of str containing the given dict as a constructor call"""
    parts = ['dict(']
    for key, value in sorted(parsed.dict_value.items()):
        parts.append(f'    {key}={value!r},')
    parts.append('),' if parsed.trailing_comma else ')')
    return parts

def indent(indentation, lines):
    """Use the given indentation prefix to indent the given lines"""
    for line in lines:
        yield f'{indentation}{line}'

def format_output(parsed):
    """Format the output"""
    formatter = format_constructor if parsed.is_literal else format_literal
    yield from indent(parsed.indentation, formatter(parsed))

def main():
    for line in format_output(parse_input(sys.stdin.read())):
        print(line)

if __name__ == '__main__':
    main()

